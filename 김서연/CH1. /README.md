# 문제점
## 예상을 빗나가는 코드
- Theater 의 enter 메서드 -> 소극장이 관람객의 초대장을 살피고, 티겟을 주고..
- 관람객과 판매원이 소극장의 통제를 받는 수동적인 존재이다.
- 이해 가능한 코드란 그 동작이 우리의 예상에서 크게 벗어나지 안흔 코드이다.
- 코드를 이해하기 어렵게 만드는 또 다른 이유는, 이 코드를 이해하기 위해 여러가지 세부적인 내용을 한꺼번에 기억하고 있어야 한다는 점이다. 
- **가장 큰 문제는 Audience 와 TicketSeller 를 변경할 경우 Theater 도 함께 변경해야 한다는 사실이다.**

## 변경에 취약한 코드
- 만약에 관람객이 가방을 안들고 있다면..? Audience 클래스에서 Bag 을 제거해야할 뿐만 아니라 Audience 의 Bag 에 직접 접근하는 Theater 의 enter 메서드 역시 수정해야 한다. 
- Theater 는 관람객이 가방을 들고 있고, 판매원이 매표소에서만 티켓을 판매한다는 지나치게 세부적인 사실에 의존해서 동작한다. 이러한 세부적인 사실중 한가지라도 바뀌면 해당 클래스뿐만 아니라, 이 클래스에 의존하는 Theater도 함께 변경해야 한다.
- 다른 클래스가 Audience 의 내부에 대해 더 많이 알면 알수록 Audience 를 변경하기 어려워진다. -> 객체 사이의 **의존성**
- 의존성은 변경에 대한 영향력을 암시한다.
- 어떤 객체가 변경될 때 그 객체에 의존하는 다른 객체도 함께 변경될 수 있다는 사실이 내포돼 있다.
- 객체지향 설계는 서로 의존하면서 협력하는 객체들의 공동체를 구축하는 것이다. 
- 우리의 목표는 어플리케이션의 기능을 구현하는데 필요한 최소한의 의존성만 유지하고 불필요한 의존성을 제거하는 것.
- 객체 사이의 의존성이 과한 경우를 가리켜 **결합도(coupling)** 이 높다고 한다.
- 결합도는 의존성과 관련돼 있기 때문에, 결합도 역시 변경과 관련이 있다.
- 설계의 목표는 객체 사이의 결합도를 낮춰 변경이 용이한 설계를 만드는 것..

# 설계 개선하기
- 첫 예제 코드에서 코드 를 이해하기 어려운 이유는 Theater 가 관람객의 가방과 판매원의 매표소에 직접 접근하기 때문이다. 
- Theater가 관람객의 가방과 판매원의 매표소에 직접 접근한다는 것은 Theater 가 Audience와 TicketSeller 에 결합된다는 것을 의미한다. 
- 해결방법은? -> 세세한 부분까지 알지 못하도록 정보를 차단.
- 다시말해서 관람객과 판매원을 **자율적인 존재** 로 만드는것.

## 자율성을 높이자.
- 