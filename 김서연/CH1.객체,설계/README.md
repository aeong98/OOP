# 문제점
## 예상을 빗나가는 코드
- Theater 의 enter 메서드 -> 소극장이 관람객의 초대장을 살피고, 티겟을 주고..
- 관람객과 판매원이 소극장의 통제를 받는 수동적인 존재이다.
- 이해 가능한 코드란 그 동작이 우리의 예상에서 크게 벗어나지 안흔 코드이다.
- 코드를 이해하기 어렵게 만드는 또 다른 이유는, 이 코드를 이해하기 위해 여러가지 세부적인 내용을 한꺼번에 기억하고 있어야 한다는 점이다. 
- **가장 큰 문제는 Audience 와 TicketSeller 를 변경할 경우 Theater 도 함께 변경해야 한다는 사실이다.**

## 변경에 취약한 코드
- 만약에 관람객이 가방을 안들고 있다면..? Audience 클래스에서 Bag 을 제거해야할 뿐만 아니라 Audience 의 Bag 에 직접 접근하는 Theater 의 enter 메서드 역시 수정해야 한다. 
- Theater 는 관람객이 가방을 들고 있고, 판매원이 매표소에서만 티켓을 판매한다는 지나치게 세부적인 사실에 의존해서 동작한다. 이러한 세부적인 사실중 한가지라도 바뀌면 해당 클래스뿐만 아니라, 이 클래스에 의존하는 Theater도 함께 변경해야 한다.
- 다른 클래스가 Audience 의 내부에 대해 더 많이 알면 알수록 Audience 를 변경하기 어려워진다. -> 객체 사이의 **의존성**
- 의존성은 변경에 대한 영향력을 암시한다.
- 어떤 객체가 변경될 때 그 객체에 의존하는 다른 객체도 함께 변경될 수 있다는 사실이 내포돼 있다.
- 객체지향 설계는 서로 의존하면서 협력하는 객체들의 공동체를 구축하는 것이다. 
- 우리의 목표는 어플리케이션의 기능을 구현하는데 필요한 최소한의 의존성만 유지하고 불필요한 의존성을 제거하는 것.
- 객체 사이의 의존성이 과한 경우를 가리켜 **결합도(coupling)** 이 높다고 한다.
- 결합도는 의존성과 관련돼 있기 때문에, 결합도 역시 변경과 관련이 있다.
- 설계의 목표는 객체 사이의 결합도를 낮춰 변경이 용이한 설계를 만드는 것..

# 설계 개선하기
- 첫 예제 코드에서 코드 를 이해하기 어려운 이유는 Theater 가 관람객의 가방과 판매원의 매표소에 직접 접근하기 때문이다. 
- Theater가 관람객의 가방과 판매원의 매표소에 직접 접근한다는 것은 Theater 가 Audience와 TicketSeller 에 결합된다는 것을 의미한다. 
- 해결방법은? -> 세세한 부분까지 알지 못하도록 정보를 차단.
- 다시말해서 관람객과 판매원을 **자율적인 존재** 로 만드는것.

## 자율성을 높이자.
- 1. Theater 의 enter 메서드에서 TheaterOffice 에 접근하는 모든 코드를 TicketSeller 내부로 숨기기.
    - 결과적으로 ticketOffice 에 대한 접근은 TicketSeller 안에서만 존재하게 된다.
    - TicketSeller 가 일을 스스로 수행하게 됨.
    - 개념적으로 물리적으로 객체 내부의 세부적인 사항을 감추는것을 **캡슐화(encapsulation)** 라고 부른다.
    - Theater 는 단지, ticketSeller 가 SellTo 메시지를 이해하고 응답할 수 있다는 사실만 알고 있을 뿐이다. 
    - Theater 는 오직 TicketSeller 의 인터페이스(interface) 에만 의존한다. 
    - 객체를 인터페이스와 구현으로 나누고, 인터페이스만을 공개하는 것은 객체 사이의 결합도를 낮추고 변경하기 쉬운 코드를 작성하기 위해 따라야 하는 기본적인 설계 원칙이다. 
    - 위의 과정을 통해 Theater 에서 TicketOffice 로의 의존성에 제거됐다. 

- 2. TicketSeller 다음으로 Audience 캡슐화를 개선하자.
    - TicketSeller 는 Audience 의 getBag 메서드를 호출해서 Audience 내부의 Bag 인스턴스에 직접 접근한다. (자율적이지 않음.)
    - Bag 에 접근하는 모든 로직을 Audience 내부로 감추기 위해 Audience 에 buy 메서드를 추가하고, TicketSeller 의 sellTo 메서드에서 getBag 메서드에 접근하는 부분을 buy 메서드로 옮기자.
    - TicketSeller와 Audience 사이의 결합도가 낮아졌다. 
    - 내부 구현이 캡슐화됐으므로 Audience 의 구현을 수정하더라도, TicketSeller 에는 영향을 미치지 않는다.
    - 다시말해, 자율적인 존재가 된것.

## 무엇이 개선됐는가 ⭐️
- 수정된 Audience 와 TicketSeller 는 자신이 가지고 있는 소지품을 스스로 관리한다. 
- 더 중요한 점은 Audience 나 TicketSeller 의 내부 구현을 변경하더라도, Theater 를 함께 변경할 필요가 없어졌다는 것이다. 

## 어떻게 한것인가 -> 캡슐화와 응집도
- 핵심은 객체 내부의 상태를 [캡슐화] 하고 객체 간에 오직 [메시지]를 통해서만 상호작용하도록 만드는 것이다.
- Theater 는 TicketSeller 의 내부에 대해서는 전혀 알지 못한다. 단지 TicketSeller 가 sellTo 메시지를 이해하고 응답할 수 있다는 사실만 알고 있을 뿐이다.
- TicketSeller 역시 Audience 내부에 대해서는 전혀알지 못한다. 단지 Audience 가 buy 메시지에 응답할 수 있고 자신이 원하는 결과를 반환할 것이라는 사실만 알고 있을 뿐이다 .
- 이렇게 연관성 없는 작업은 다른 객체에게 [위임] 하는 객체를 가리쳐 [응집도(cohesion)] 이 높다고 말한다. 
- 자신의 데이터를 스스로 처리하는 자율적인 객체를 만들면 결합도를 낮출 수 있을뿐더로 응집도를 높일 수 있다. 
- **외부의 간섭을 최대한 배제하고 메시지를 통해서만 협력하는 자율적인 객체들의 공동체를 만드는 것이 훌륭한 객체지향 설계를 얻을 수 있는 지름길**

## 절차지향과 객체지향
- 프로세스와 데이터를 별도의 모듈에 위치시키는 방식은 [절차적 프로그래밍 (Procedural Programmming)] 이라고 한다.
- 절차적 프로그래밍은 우리의 직관에 위배된다. 
- 절차적 프록래밍은 프로세스가 필요한 모든 데이터에 의존해야 한다는 근본적인 문제점 때문에 변경에 취약할 수 밖에 없다.
- **해결 방법은 자신의 데이터를 스스로 처리하도록 프로세스의 적절한 단계를 Audience 와 TicketSeller 로 이동시키는 것.**


## 책임의 이동
- 위 두 방식에 근본적인 차이를 만드는 것은다 **[책임의 이동(shift of responsibiligy)]** 이다.
- 변경전 절차적 설계에서는 Theater가 전체적인 작업을 도맡아 했다.
- 책임이 개별 객체로 이동한다 = 책임의 이동
- 각 객체는 자신을 스스로 책임진다.
- 객체지향 프로그래밍을 =/ 데이터와 프로세의 하나의 단위 
- **객체지향 설계의 핵심은 적절한 객체에 적절한 책임을 할당하는 것이다.**
- 따라서, 객체가 어떤 데이터를 가지느냐보나는 객체에 어떤 책임을 할당할 것이냐에 초점을 맞춰야 한다. 


## 더 개선할 수 있다.
- 근데 트레이드 오프.. 
- 어떤 기능을 설계하는 방법은 한가지 이상일 수 있다.
- 동일한 기능을 한 가지 이상의 방법으로 설계할 수 있기 때문에, 설계는 트레이드오프의 산물이다. 
- 객체지향 세계에서 각 객체는 능동적이고 자율적인 존재이다. = **의인화**
